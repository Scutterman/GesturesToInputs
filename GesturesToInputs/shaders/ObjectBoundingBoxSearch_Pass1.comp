#version 430 core

struct ObjectSearchData {
    ivec4 boundingBox; // minimum left and minimum top, maximum right and maximum bottom of all contiguous areas
    uint area; // Number of pixels inside the bounding box
    uint topLeftSampleIndex;
    uint isPartOfAnObject;
    uint isObjectTopLeft;
};

layout(std430, binding=1) buffer data {
    ObjectSearchData samples[];
};

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

uniform layout(r8ui) uimage2D texture0;
uniform ivec2 imageDimensions;
uniform ivec2 samplePixelDimensions; // width and height of each sample in pixels - larger sample size is faster but less accurate
uniform ivec2 sampleSize; // number of horizontal and vertical samples in the image
uniform uint numberOfPasses; // Higher number of passes = higher chance at successfully working out the bounding box but higher processing time. May be possible to best-guess on CPU based on number of sample rows and columns
uniform uint threshold; // If a bounding box contains fewer than this many pixels, the object is discounted. Higher = less work for the next stage but may discount valid markers.

// Propogate the lowest top/left and the highest right/bottom values between two samples
void atomicBoundingBoxUpdate(uint currentSample, uint targetSample) {
    atomicMin(samples[currentSample].boundingBox.x, samples[targetSample].boundingBox.x);
    atomicMin(samples[currentSample].boundingBox.y, samples[targetSample].boundingBox.y);
    atomicMax(samples[currentSample].boundingBox.z, samples[targetSample].boundingBox.z);
    atomicMax(samples[currentSample].boundingBox.w, samples[targetSample].boundingBox.w);
    atomicMin(samples[targetSample].boundingBox.x, samples[currentSample].boundingBox.x);
    atomicMin(samples[targetSample].boundingBox.y, samples[currentSample].boundingBox.y);
    atomicMax(samples[targetSample].boundingBox.z, samples[currentSample].boundingBox.z);
    atomicMax(samples[targetSample].boundingBox.w, samples[currentSample].boundingBox.w);
}

void main()
{
    uint sampleColumn = gl_WorkGroupID.x;
    uint sampleRow = gl_WorkGroupID.y;
    uint sampleIndex = sampleColumn + (sampleRow * sampleSize.x);
    
    // Reset sample data
    samples[sampleIndex].isObjectTopLeft = 0;
    samples[sampleIndex].area = 0;
    samples[sampleIndex].topLeftSampleIndex = sampleIndex;
    samples[sampleIndex].boundingBox = ivec4(sampleColumn, sampleRow, sampleColumn+1, sampleRow+1);

    // Determine whether sample has enough pixels to be part of an object
    uint balance = 0;
    uint target = (samplePixelDimensions.x * samplePixelDimensions.y) / 2;
    for (uint j = 0; j < samplePixelDimensions.y; j++) {
        for (uint i = 0; i < samplePixelDimensions.x; i++) {
            uint x = min((sampleColumn * samplePixelDimensions.x) + i, imageDimensions.x);
            uint y = min((sampleRow * samplePixelDimensions.x) + j, imageDimensions.y);
            vec4 pixel = imageLoad(texture0, ivec2(x, y));
            balance += pixel.x == 255 ? 1 : 0;
        }
    }

    samples[sampleIndex].isPartOfAnObject = (balance >= target) ? 1 : 0;
    memoryBarrier();

    // Susurration - lowest values for top & left / highest values for right & bottom will propogate through the whole object
    // Only need to check certain directions because other samples will update our values for the other direction when they make their checks
    for (uint i = 0; i < numberOfPasses; i++) {
        int leftIndex = int(sampleIndex) - 1;
        if (samples[sampleIndex].isPartOfAnObject == 1 && leftIndex > 0 && samples[leftIndex].isPartOfAnObject == 1) {
            atomicBoundingBoxUpdate(sampleIndex, leftIndex);
        }
        
        int topIndex = int(sampleIndex) - sampleSize.x;
        if (samples[sampleIndex].isPartOfAnObject == 1 && topIndex > 0 && samples[topIndex].isPartOfAnObject == 1) {
            atomicBoundingBoxUpdate(sampleIndex, topIndex);
        }
        
        int topLeftIndex = (int(sampleIndex) - sampleSize.x) - 1;
        if (samples[sampleIndex].isPartOfAnObject == 1 && topLeftIndex > 0 && samples[topLeftIndex].isPartOfAnObject == 1) {
            atomicBoundingBoxUpdate(sampleIndex, topLeftIndex);
        }
        
        // Unfortunately need to wait and make sure all samples have finished their checks this pass before we continue
        memoryBarrier();
    }

    // Update this sample's information with the propogated object values
    uint topLeftIndex = samples[sampleIndex].boundingBox.x + (samples[sampleIndex].boundingBox.y * sampleSize.x);
    samples[sampleIndex].topLeftSampleIndex = topLeftIndex;
    uint width = samples[sampleIndex].boundingBox.z - samples[sampleIndex].boundingBox.x;
    uint height = samples[sampleIndex].boundingBox.w - samples[sampleIndex].boundingBox.y;
    
    uint area = width * height;
    samples[sampleIndex].area = area < threshold ? 0 : area;
    samples[sampleIndex].isPartOfAnObject = area < threshold ? 0 : 1;

    // Only store the final values in one sample so it's quicker to isolate in the next stage
    if (samples[sampleIndex].isPartOfAnObject == 1) {
        samples[topLeftIndex].isObjectTopLeft = 1;
        samples[topLeftIndex].area = area; // This could store an exact number of pixels in the object using the "balance" variable and an atomic add.
        samples[topLeftIndex].boundingBox = samples[sampleIndex].boundingBox;
    }
}
